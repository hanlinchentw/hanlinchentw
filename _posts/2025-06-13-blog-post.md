---
title: "Bringing Container–Presentational to SwiftUI"
date: 2025-06-13
permalink: /posts/2025/06/bringing-containerpresentational/
author: "Leo Chen"
tags:
  - SwiftUI
  - MVVM
  - Architecture
  - React
---

### A React-inspired approach to modular, clean SwiftUI architecture

## Table of Contents

- Introduction
- Understanding the Presentational-Container Pattern
- Building Presentational Components
- Implementing Container Components
- A Real-World Architecture
- Summary
- Reference

---

## Introduction

Ever tried updating `@State` from a ViewModel in SwiftUI, only to hit a wall? You’re not alone. MVVM promises separation of concerns and improved testability—but its imperative nature often clashes with SwiftUI’s declarative design. The result? Awkward workarounds, fragile code, and mounting frustration.

As one popular [Apple Developer Forums thread](https://developer.apple.com/forums/thread/699003) puts it: forcing MVVM onto SwiftUI is like "taking the magic power from SwiftUI." Instead of embracing the framework’s strengths, you're constantly fighting against them.

Take this common scenario:

```swift
struct ContentView: View {
    @Environment(\.dismiss) var dismiss
    @State var isLoading = false
    @StateObject var viewModel = ViewModel()

    var body: some View {
        if isLoading {
            ProgressView()
        } else {
            Text("Loaded!")
        }
    }
}

final class ViewModel: ObservableObject {
    func onAppear() {
      // Can’t directly change `isLoading` in the view.
    }

    func onPressCancel() {
      // Can’t directly call `dismiss` in the view.
    }
}
```

Here, the ViewModel has no access to the view’s local @State or environment values like dismiss. This disconnect often leads to awkward binding gymnastics or bloated view logic—both of which violate MVVM’s original intent.

So how can we preserve MVVM’s benefits—modularity, testability, maintainability—without the friction?

Enter the Presentational–Container pattern: a SwiftUI-native refinement that bridges the gap between business logic and declarative UI. By cleanly separating stateful containers from stateless views, it lets you enjoy the best of both worlds.

---

## Understanding the Presentational-Container Pattern

This pattern, originally popularized in the React community, separates rendering from logic by splitting UI into two parts: containers that manage state and behavior, and presentational components that focus solely on layout and interaction. The result is simpler, more testable, and reusable code.

<img alt="Container / Presentational Component Pattern" src="https://substack-post-media.s3.amazonaws.com/public/images/8f78ee1b-2057-422a-84db-976d1ac1f3e6_800x369.png">

Applied to SwiftUI, this pattern embraces its declarative nature while preserving MVVM’s core strength: separation of concerns.

- **Container:** Manages state, connects to the ViewModel, prepares props, and handles SwiftUI-specific behaviors like alerts or navigation.
- **Presentational Component:** A stateless, reusable view responsible only for presentation.

This structure avoids fragile workarounds and leads to a cleaner, more maintainable codebase.

---

## Building Presentational Components

Presentational components are pure, stateless, and easy to reason about. The key principle is simple: Presentational Components never own state. Instead, they declare what they need and let the container provide it.

```swift
struct FeedView: View {
    let isLoading: Bool
    let feeds: [Feed]
    let onAppear: () -> Void
    let onPressFeed: (Feed) -> Void
    let onRefresh: () -> Void

    var body: some View {
        ZStack {
            if isLoading {
                ProgressView("Loading...")
            } else {
                List {
                    ForEach(feeds) { feed in
                        FeedView(feed: feed, onPressFeed: onPressFeed)
                    }
                }
                .refreshable(action: onRefresh)
            }
        }
        .onAppear(perform: onAppear)
    }
}
```

Presentational views are:

- ✅ Stateless
- ✅ Easily previewable
- ✅ Reusable across use cases
- ✅ Simple to test

Because they don’t depend on how data is fetched or stored, these components are highly reusable and testable—whether your data comes from an API, a local cache, or mock objects.

---

## Implementing Container Components

The Presentational-Container pattern doesn’t replace MVVM—it builds on it.

**Traditional MVVM Structure:**

```
View ↔ ViewModel ↔ Model
```

**Enhanced with Container:**

```
Container ↔ ViewModel ↔ Model
    ↓
Presentational Component
```

The ViewModel still handles business rules and data, but the Container acts as the SwiftUI-native layer that:

- Maps ViewModel state to presentational props
- Owns ephemeral state (`@State`)
- Manages side effects and lifecycle events

Here's how it works in practice:

```swift
class FeedViewModel: ObservableObject {
    @Published var isFetchingData = false
    @Published var feeds: [Feed] = []
    @Published var error: Error?

    func loadFeeds() async { /* business logic */ }
    func refreshFeeds() async { /* business logic */ }
}

struct FeedContainerView: View {
    @Environment(\.router) var router: Router
    @StateObject private var viewModel = FeedViewModel()
    @State private var selectedFeed: Feed?

    var body: some View {
        FeedView(
            isLoading: viewModel.isFetchingData,
            feeds: viewModel.feeds,
            errorMessage: viewModel.errorMessage,
            onAppear: { Task { await viewModel.loadFeeds() } },
            onPressFeed: handleFeedSelection,
            onRefresh: { Task { await viewModel.refreshFeeds() } },
            onRetry: { Task { await viewModel.loadFeeds() } }
        )
    }

    private func handleFeedSelection(_ feed: Feed) {
        selectedFeed = feed
        router.push(.feedDetail(feed))
    }
}
```

Here, the container connects the ViewModel’s output to the UI, handles transient selection state, and drives navigation. The presentational view stays pure and reusable.

Container components handle everything presentational views shouldn’t:

- `@State` / `@StateObject` for transient UI state
- ViewModel interaction and coordination
- Dependencies like `@Environment` and injected services
- Side effects (networking, navigation, etc.)
- Lifecycle and user interaction callbacks

---

## A Real-World Architecture

A full SwiftUI app using this pattern might be structured like this:

<img alt="Architecture Diagram" src="https://substack-post-media.s3.amazonaws.com/public/images/2e8d9a77-3168-47c9-ae2d-022b8915a996_918x569.png">

This architecture embraces SwiftUI’s strengths—clear data flow, testability, and composability—without abandoning structure or scalability.

---

## Summary

**What Containers Do**

- Transform business state into UI-ready props
- Handle SwiftUI-specific concerns (alerts, sheets, navigation)
- Coordinate side effects and user interactions
- Bridge imperative logic with declarative UI

**Why It Works**

- Reduces cognitive load – views stay focused purely on layout and interaction
- Enhances reusability – presentational views work with any data source (API, DB, mock)
- Simplifies testing – pure components are trivial to test and preview
- Improves maintainability – separation of concerns makes code easier to reason about

Think of containers as smart adapters: they manage orchestration so your views can stay simple, pure, and focused.

No matter your architecture—MVVM, TCA, or something custom—this pattern helps you write cleaner, more scalable SwiftUI code by working with the framework, instead of fighting against it.

---

## Reference

- [React Design Patterns: The Container/Presentational Pattern](https://medium.com/@vitorbritto/react-design-patterns-the-container-presentational-pattern-775b91aa0c49)
- [Introducing MVVM into your SwiftUI project](https://www.hackingwithswift.com/books/ios-swiftui/introducing-mvvm-into-your-swiftui-project)
- [Stop using MVVM for SwiftUI](https://developer.apple.com/forums/thread/699003)

© 2025 Leo Chen
